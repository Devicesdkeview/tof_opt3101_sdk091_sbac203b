<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OPT3101SDK: OPT3101SDK Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OPT3101SDK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">OPT3101SDK Documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Version 0.8.0</p>
<h2>Overview</h2>
<p>OPT3101SDK is a C++ SDK that supports TI <a href="http://www.ti.com/product/OPT3101">OPT3101</a> AFE.</p>
<p>Link to FAQ section <a href="#FAQ">here</a></p>
<p>The SDK provides C++ library of functions to control and calibrate <a class="el" href="namespace_o_p_t3101.html" title="OPT3101::device declaration This is declared here to avoid cyclic reference of classes. ">OPT3101</a> based systems. <a class="el" href="namespace_o_p_t3101.html" title="OPT3101::device declaration This is declared here to avoid cyclic reference of classes. ">OPT3101</a> Configurator tool is required to generate certain functions since the SDK's functions depend on how the <a class="el" href="namespace_o_p_t3101.html" title="OPT3101::device declaration This is declared here to avoid cyclic reference of classes. ">OPT3101</a> system is configured.</p>
<p>Here is an overview on what the SDK offers:</p>
<ul>
<li>Register interface where the registers can be accessed by register names instead of physical address<ul>
<li>Translation to physical address and data read/write fields are translated by the SDK</li>
<li>This the the fundamental basis on which the SDK is built which makes the calibration routines and methods more meaningful to read and understand</li>
<li>The names of the registers match with the data sheet making seamless reference for documentation.</li>
</ul>
</li>
<li>Methods to control and access group of registers to achieve specific functionality like the following<ul>
<li>Initializing the hardware on power-up to bring up to the desired state</li>
<li>A Specific calibration for a particular configuration which involves a bunch of register reads writes and extraction of data</li>
</ul>
</li>
<li>Container data types (classes) to hold, analyze and report calibration data for the systems.<ul>
<li>During calibration, data needs to be analyzed and stored.These classes act as intermediate containers to store and derive register values.</li>
</ul>
</li>
<li>Template classes for environmental and host controls<ul>
<li>Calibration routines require specific environmental conditions like chamber temperature, target at specified distance, which is handled by template classes.</li>
<li>Register physical I2C interface is host specific which are also handled by template classes.</li>
<li>User is expected to implement/modify the template classes based on the environmental control hardware and host specifications.</li>
</ul>
</li>
</ul>
<hr/>
<h2><a class="anchor" id="Prereq"></a>Prerequisites</h2>
<ul>
<li>C++ (03) compiler</li>
<li>User basic knowledge of C++ to edit source code, compile and get it working based on <a class="el" href="namespace_o_p_t3101.html" title="OPT3101::device declaration This is declared here to avoid cyclic reference of classes. ">OPT3101</a> system, host and environment.</li>
<li>Basic understanding of <a href="http://www.ti.com/product/OPT3101">OPT3101</a> AFE device and various register configurations</li>
<li>Basic understanding of <a href="http://www.ti.com/lit/ug/sbau310/sbau310.pdf">OPT3101 Calibration</a></li>
<li><a class="el" href="namespace_o_p_t3101.html" title="OPT3101::device declaration This is declared here to avoid cyclic reference of classes. ">OPT3101</a> Configurator tool configuration and output .cpp file generated from the tool<ul>
<li>This file has method definition to initialize the hardware and allocate memory to calibration containers based on hardware configuration</li>
</ul>
</li>
<li>As a reference <a href="http://www.ti.com/tool/OPT3101EVM">OPT3101EVM</a> hardware interface examples are provided. A sample configuration for super-HDR mode is also included<ul>
<li>If TI EVM reference is compiled as such setupapi.lib needs to be added to the linker path to get the serial ports working (CDC interface)</li>
<li>TI EVM drivers are also required.</li>
<li>COM port in the file <a href="host_controller_8cpp.html">hostController.cpp</a> needs to be updated based on the EVM enumeration.</li>
<li>Port to be selected is the port number which enumerates with following hardware id <a href="https://e2e.ti.com/cfs-file/__key/communityserver-discussions-components-files/989/8461.ControlPort.PNG">USB VID_2047&amp;PID_0A3C&amp;REV_0200&amp;MI00</a></li>
</ul>
</li>
</ul>
<hr/>
<h2><a class="anchor" id="Limitations"></a>Limitations and expectations</h2>
<h3>SDK is a</h3>
<ul>
<li>Library of functions to help users configure, control and calibrate the <a href="http://www.ti.com/product/OPT3101">OPT3101</a> system on their host environment.</li>
<li>Library that needs porting and tweaking to users' hardware and environment specifications.<ul>
<li>I2C Interface:<ul>
<li>For eg: Commands to I2C register interface varies depending on hardware and host.</li>
<li>This SDK provides translation of register names to physical address and data to be written to h/w, however the actual command to write and read I2C to hardware is host and h/w specific.</li>
<li>The SDK provides a template class filled with <a href="http://www.ti.com/tool/OPT3101EVM">OPT3101EVM</a> control example which user needs to modify based on their host and hardware</li>
</ul>
</li>
<li>Environmental control:<ul>
<li>Some calibration steps require a target to be placed at a distance based on <a href="http://www.ti.com/product/OPT3101">OPT3101</a> system configuration. The SDK provides a template class which user needs to implement based on host and environment.</li>
<li>Another example is for temperature coefficients chamber temperature needs to be set, for which template classes are provided which needs to be implemented by user.</li>
</ul>
</li>
<li>Calibration file storage:<ul>
<li>SDK uses c++ std::fstream to store files in ASCII format which may not by practical in MCU like environment, in such cases users need to implement their own method of storage to non-volatile memory for some of the calibration steps.</li>
</ul>
</li>
<li>Report methods<ul>
<li>Calibration classes have report() method which print readable analysis of the classes using stdio::printf statements to stout. This may be impractical in some host environments, in such cases users need to implement their own display methods to view such classes.</li>
</ul>
</li>
</ul>
</li>
<li>Library that is powerful enough to build a full fledged design and factory calibration tool for on <a href="http://www.ti.com/product/OPT3101">OPT3101</a> system that works of various different hosts and environments.</li>
<li>Coefficients estimation as part of SDK are simplified example algorithms based on 2 point linear fitting. A more complicated linear regression fitting may be required to be implemented inside or outside of SDK based on accuracy desired by the system.<ul>
<li>For eg: Temperature coefficients are determined by just 2 temperature points, however in reality a multi point line of best fit method may be required.</li>
<li>Users can export the data to file system using methods saveToFile and analyze and curve fit data using mathematical tools.</li>
<li>Ones the coefficients are identified, they can be fed back to the class using the library functions and written back to files/load to the h/w using SDK methods</li>
<li>Calculating coefficients outside the SDK is critical especially for <a class="el" href="class_o_p_t3101_1_1phase_ambient_coff_c.html" title="Class that holds ambient phase coefficient related registers and values. ">OPT3101::phaseAmbientCoffC</a> class coefficients since they involve a PWL curve fit not implemented in the SDK</li>
</ul>
</li>
</ul>
<h4>SDK is <b>NOT</b></h4>
<ul>
<li>Readily available calibration tool to calibrate <a href="http://www.ti.com/product/OPT3101">OPT3101</a> system on users' host without user efforts to port and compile on host environment</li>
</ul>
<hr/>
<h2>Terminology</h2>
<ul>
<li><a href="http://www.ti.com/lit/ug/sbau310/sbau310.pdf">Calibration</a>: This is the process in which coefficients are determined for various phenomenon like temperature, ambient and applied to <a href="http://www.ti.com/product/OPT3101">OPT3101</a> system for correction</li>
<li>Calibration session: This is a session from power-up of h/w ,reset, initialization, setting up environment and measuring the coefficients and storing them to file. (To be shared among different sessions)</li>
<li>Per design Calibration: These are coefficients which are needed per system design (or PCB/optics design). Coefficients determination may need to be done for several units to understand the variation from unit to unit. In almost every case of system only 1 set of coefficients may be determined from all the units under test and used for all the units in factory calibration.</li>
<li>Per unit factory calibration: These are coefficients that are required per unit during factory calibration.</li>
</ul>
<hr/>
<h2>Pre-processor definitions</h2>
<p>Following pre-processor definitions are used in the SDK to hide several sections of the SDK to compiler. Users can device to define or not define these constructs based on host requirements All the pre-processors are defined in the <a class="el" href="host_controller_8h.html">hostController.h</a> file</p><ul>
<li><a class="el" href="host_controller_8h.html#a140baa610a82653550ea9aa0a85feb43" title="This pre-processor derivative dictates whether to load stdio library which contains printf and sprint...">OPT3101_USE_STDIOLIB</a> This pre-processor derivative dictates whether to load stdio library which constants stdio::printf and stdio::sprintf methods<ul>
<li>This is enabled by default in SDK. Not defining this derivate would disable all stdio::sprintf and stdio::printf methods.</li>
<li>This means that the report() methods which displays user readable class contents on screen for several class will be blank to the compiler.</li>
<li>All file storage and load methods are hidden to compiler since the name for the files cannot be resolved without the stdio::sprintf method</li>
<li>User is expected to disable this only on RTOS or MCU like environments when printing on console or file storage/load doesn't make sense on the host</li>
<li>User needs to find a way to transfer the calibration class(es) data from and to the RTOS host to a PC for debug, analysis and curve fitting of coefficients.</li>
</ul>
</li>
<li><a class="el" href="host_controller_8h.html#a3ca6673b36debd7f489557558d93fe38" title="This pre-processor derivative dictates whether to load std::iostream and std::fstream libraries This ...">OPT3101_USE_STREAMLIB</a> This pre-processor derivative dictates whether to load std::iostream and std::fstream libraries<ul>
<li>This is enabled by default in SDK. Not defining this derivate would disable all the std::iostream and related libraries.</li>
<li>File storage will no longer be possible with the SDK since the file storage and load uses these libraries</li>
<li>This means that the report() methods which displays user readable class contents on screen for several class will be blank to the compiler.</li>
<li>All stream operator overload methods for classes are hidden to the compiler.</li>
<li>All methods related to loadFromFile and saveToFile are blank methods to the compiler.</li>
<li>User is expected to disable this only on RTOS or MCU like environments file storage/load doesn't make sense on the host</li>
<li>User needs to find a way to transfer the calibration class(es) data from and to the RTOS host to a PC for debug, analysis and curve fitting of coefficients.</li>
</ul>
</li>
<li><a class="el" href="host_controller_8h.html#af9ad545b8deb1b3c44ff9168213be470" title="This pre-processor derivative dictates whether to use included serial.h library This is enabled by de...">OPT3101_USE_SERIALLIB</a> This pre-processor derivative dictates whether to use included <a class="el" href="serial_8h.html">serial.h</a> library<ul>
<li>This is enabled by default in SDK. Not defining this derivate would disable the serial communication capability from the host</li>
<li>The included <a href="https://github.com/wjwwood/serial">serial.h</a> library is from MIT under MIT license will be hidden to compiler on disabling this derivative</li>
<li>In case of usage of SDK with <a href="http://www.ti.com/tool/OPT3101EVM">OPT3101EVM</a> , this derivate is required.</li>
<li>User can disable this derivative and use their own library based on the h/w.</li>
<li>In that case the I2C read and writes operations need to be handled by user in the <a class="el" href="host_controller_8cpp.html">hostController.cpp</a></li>
</ul>
</li>
<li><a class="el" href="host_controller_8h.html#a913d77ed1a69aa41135440e6d7e8ec6c" title="This pre-processor derivative dictates whether the host is PC In a PC environment file storage...">HOST_PC</a> This pre-processor derivative dictates whether the host is PC<ul>
<li>This derivatives when set enables all the 3 <a class="el" href="host_controller_8h.html#a140baa610a82653550ea9aa0a85feb43" title="This pre-processor derivative dictates whether to load stdio library which contains printf and sprint...">OPT3101_USE_STDIOLIB</a> , <a class="el" href="host_controller_8h.html#a3ca6673b36debd7f489557558d93fe38" title="This pre-processor derivative dictates whether to load std::iostream and std::fstream libraries This ...">OPT3101_USE_STREAMLIB</a> and <a class="el" href="host_controller_8h.html#af9ad545b8deb1b3c44ff9168213be470" title="This pre-processor derivative dictates whether to use included serial.h library This is enabled by de...">OPT3101_USE_SERIALLIB</a></li>
<li>User can disable this derivative in RTOS or MCU environment, however need to take care of handling calibration data as specified in above sections</li>
</ul>
</li>
</ul>
<hr/>
<h2><a class="anchor" id="Levels"></a>Methods abstraction levels</h2>
<p>The master class <a class="el" href="class_o_p_t3101_1_1device.html" title="This is the master class that integrates all the OPT3101SDK functions. ">OPT3101::device</a> has several methods for various different tasks and coefficient determination. They are classified to different levels based on simplicity. </p><h3>Level 3 methods (Simplest abstraction)</h3>
<ul>
<li>These are methods that provide the simplest level of abstraction to the user.</li>
<li>All the methods don't require any arguments to be passed.</li>
<li>These methods internally call lower level methods methods to achieve the targeted functionality</li>
<li>All steps are listed in the documentation for each method.</li>
<li><b>It is highly recommended to understand the steps before using these methods</b></li>
<li><b>Some methods will require user to edit and set up some parameters</b>. This is true for phase offset related methods where reference distances will have to be setup.</li>
<li>The list below is the recommended order in which these sessions are meant to be run</li>
</ul>
<p>Here is the list of Level 3 methods</p><ol type="1">
<li><a class="el" href="class_o_p_t3101_1_1device.html#a0dd8c59bc93c392f8d3f430697457415" title="method for calibration session run the first time the board is brought up Method is a sequence of ste...">OPT3101::device::calibrationSession_firstTimeBringUp</a> &ndash;&gt; As name suggest this method is used to bring up the board and do basic measurements</li>
<li><a class="el" href="class_o_p_t3101_1_1device.html#a6b44ee9769ae8a2debff7b475bccdfe4" title="method for calibration of crosstalk temperature coefficients Method is a sequence of steps recommende...">OPT3101::device::calibrationSession_perDesignCalibrationCrosstalkTemp</a> &ndash;&gt; This measures the crosstalk temperature coefficients for the system</li>
<li><a class="el" href="class_o_p_t3101_1_1device.html#aec05fdf2f9780dea74305720ccb1cf32" title="method for calibration of phase temperature coefficients This is recommended to be run on a few units...">OPT3101::device::calibrationSession_perDesignCalibrationPhaseTemp</a> &ndash;&gt; This measures the phase temp coefficients for the system</li>
<li><a class="el" href="class_o_p_t3101_1_1device.html#a94c4e35aa43bc53eb8fe0d4c364aea25" title="method for calibration of phase ambient coefficients This is recommended to be run on a few units per...">OPT3101::device::calibrationSession_perDesignCalibrationPhaseAmbient</a> &ndash;&gt; This measures the phase ambient coefficients for the system</li>
<li><a class="el" href="class_o_p_t3101_1_1device.html#a3b278687f5414b66c614d83dcf229f80" title="method for calibration of phase ambient coefficients after manually curve fitting This is recommended...">OPT3101::device::calibration_perDesignCalibrationPhaseAmbientSetCoffAfterCurveFit</a> &ndash;&gt; Curve fit data needs to be entered back to the SDK after calculations on PC</li>
<li><a class="el" href="class_o_p_t3101_1_1device.html#abad5b2d7405e735fa80041dbbf47502c" title="method for calibration during factory for each unit of the system This is recommended to be run on a ...">OPT3101::device::calibrationSession_perUnitFactoryCalibration</a> &ndash;&gt; Recommended list of functions to be run during production calibration in factory</li>
<li><a class="el" href="class_o_p_t3101_1_1device.html#aa0a1b1f37d9aea753d7910de3e8c2799" title="method to store the calibration to EERPOM or some other from on non-volatile memory to be loaded on p...">OPT3101::device::calibrationSession_perUnitFactoryCalibrationWriteRegisterDataToNonVolatileMemory</a> &ndash;&gt; Steps to store factory calibration data to non-volatile memory</li>
</ol>
<h3>Level 2 methods</h3>
<ul>
<li>These are methods are called by Level 3 methods.</li>
<li>These methods can be directly called by user at top level as well.</li>
<li>These methods require arguments to be passed.</li>
<li>These methods internally call ever lower level methods methods to achieve the targeted functionality</li>
<li>All steps are listed in the documentation for each method.</li>
<li><b>It is highly recommended to understand the steps before using these methods</b></li>
</ul>
<p>Here is the list of Level 2 methods</p><ol type="1">
<li><a class="el" href="class_o_p_t3101_1_1device.html#a48b320dfe4376bf62043d10ba937e8cd" title="loads all illum crosstalk set specified by OPT3101 configuration tool to h/w Method loads all the ill...">OPT3101::device::loadIllumCrosstalkSet</a> &ndash;&gt; Loads the set of illum crosstalk registers</li>
<li><a class="el" href="class_o_p_t3101_1_1device.html#ab384cacd80cd32643b7029fe59428e92" title="loads all illum crosstalk temp coefficients set specified by OPT3101 configuration tool to h/w Method...">OPT3101::device::loadIllumCrosstalkTempCoffSet</a> &ndash;&gt; Loads the set of illum crosstalk temp coefficient registers</li>
<li><a class="el" href="class_o_p_t3101_1_1device.html#a69d7fbb471d186845242774d7f2c86a8" title="loads all phase temp coff set specified by OPT3101 configuration tool to h/w Method loads all the pha...">OPT3101::device::loadPhaseOffsetTempCoffSet</a> &ndash;&gt; Loads the set of phase temperature coefficient registers</li>
<li><a class="el" href="class_o_p_t3101_1_1device.html#ac70129fa0dacd700b19349087f000f76" title="loads phase ambient coff set to h/w Method loads all the phase ambient coff registers from OPT3101::c...">OPT3101::device::loadPhaseAmbientCoffSet</a> &ndash;&gt; Loads the set of phase ambient coefficient registers</li>
<li><a class="el" href="class_o_p_t3101_1_1device.html#a9fed055b5998d93bd37f26388ec8b0a8" title="loads all phase offset set specified by OPT3101 configuration tool to h/w Method loads all the phase ...">OPT3101::device::loadPhaseOffsetSet</a> &ndash;&gt; loads the set of phase offset registers</li>
</ol>
<h3>Level 1 methods</h3>
<ul>
<li>These are methods are called by Level 3 and Level 2 methods.</li>
<li>These methods can be directly called by user at top level as well.</li>
<li>Some of these methods require multiple arguments to be passed.</li>
<li>These methods internally call ever lower level methods methods to achieve the targeted functionality</li>
<li>All steps are listed in the documentation for each method.</li>
<li><b>It is highly recommended to understand the steps before using these methods</b></li>
<li><b>Some methods will require user to edit and set up some parameters</b>. This is true for phase offset related methods where reference distances will have to be setup.</li>
</ul>
<p>Here is the list of Level 1 methods</p><ol type="1">
<li><a class="el" href="class_o_p_t3101_1_1device.html#a1d37b22f535d8130c7f24799f7fa3c33" title="resets device Template function which involves hostController::resetDevice method ...">OPT3101::device::reset</a> &ndash;&gt; Resets the <a class="el" href="namespace_o_p_t3101.html" title="OPT3101::device declaration This is declared here to avoid cyclic reference of classes. ">OPT3101</a> system h/w</li>
<li><a class="el" href="class_o_p_t3101_1_1device.html#ae3b7fb4f9a8f1dee330523e034aa9460" title="initializes the device Definition for the method is generated by the OPT3101 configuration generator ...">OPT3101::device::initialize</a> &ndash;&gt; Initializes the <a class="el" href="namespace_o_p_t3101.html" title="OPT3101::device declaration This is declared here to avoid cyclic reference of classes. ">OPT3101</a> system h/w</li>
<li><a class="el" href="class_o_p_t3101_1_1device.html#a44f832d6edbfb26db079ddba4debfdba" title="Measures and corrects internal crosstalk Method abstracts the internal crosstalk measurement. There are bunch of steps and register read/writes involved to measure and correct internal crosstalk which this method handles. This method is recommended to be run every time after power-up. ">OPT3101::device::measureAndCorrectInternalCrosstalk</a> &ndash;&gt; Measures and corrects internal crosstalk</li>
<li>OPT3101::device::measureIllumCrosstalk &ndash;&gt; Measures illum crosstalk registers</li>
<li>OPT3101::device::measurePhaseOffset &ndash;&gt; Measures phase offset registers</li>
<li><a class="el" href="class_o_p_t3101_1_1device.html#acb915ffb10d3c725fe4a58f22d69d27d" title="load illum crosstalk from OPT3101::crosstalkC class to the h/w Method loads the registers from OPT310...">OPT3101::device::loadIllumCrosstalk</a> &ndash;&gt; Loads illum crosstalk registers</li>
<li><a class="el" href="class_o_p_t3101_1_1device.html#a941591aefa8b4c9b7436ac8f216938ed" title="load phase offset from OPT3101::phaseOffsetC class to the h/w Method loads the registers from OPT3101...">OPT3101::device::loadPhaseOffset</a> &ndash;&gt; Loads phase offset registers</li>
<li><a class="el" href="class_o_p_t3101_1_1device.html#a450bc6b5bcd3e6b232d4352229a2829c" title="load crosstalk temperature coefficients from OPT3101::crosstalkTempCoffC class to the h/w Method load...">OPT3101::device::loadIllumCrosstalkTempCoff</a> &ndash;&gt; Loads the illum crosstalk temperature coefficient registers</li>
<li><a class="el" href="class_o_p_t3101_1_1device.html#a71e7ec6f26d54ea7cba11bf1c4132489" title="load phase offset temperature coefficients from OPT3101::phaseTempCoffC class to the h/w Method loads...">OPT3101::device::loadPhaseOffsetTempCoff</a> &ndash;&gt; Loads the phase temperature coefficient registers</li>
<li><a class="el" href="class_o_p_t3101_1_1device.html#aa34206319a66be86de29789a1c24e3f7" title="load phase ambient coefficients from OPT3101::phaseAmbientCoffC class to the h/w Method loads the reg...">OPT3101::device::loadPhaseAmbientCoff</a> &ndash;&gt; Loads the phase ambient coefficient registers</li>
</ol>
<h3>Level 0 methods</h3>
<p>These are private members of the class hidden to the users internally used by Level 1 methods </p><hr/>
<h2>Critical files in SDK and their purpose</h2>
<h3><a class="el" href="_o_p_t3101device_8h.html">OPT3101device.h</a></h3>
<ul>
<li>Master class instance of which <b>needs to be declared by user in the program</b></li>
<li>Has methods for device reset, initialization, calibration routines etc as listed in the SDK documentation.</li>
<li>All calibration routines, register interfaces are availalbe as methods and variables inside this master class instance.</li>
<li>For eg: <a class="el" href="class_o_p_t3101_1_1device.html" title="This is the master class that integrates all the OPT3101SDK functions. ">OPT3101::device</a> dev; is declared in the program, <a href="class_o_p_t3101_1_1device.html#a0dd8c59bc93c392f8d3f430697457415">dev.calibrationSession_firstTimeBringUp()</a> would perform the steps to power-up, reset and initialize the device and perform initial calibration steps.</li>
</ul>
<h3><a class="el" href="_o_p_t3101__configuration_8cpp.html">OPT3101_configuration.cpp</a></h3>
<ul>
<li>This is the file created by the OPT3101-Configurator tool based on user inputs</li>
<li>This is a critical file that sets up and allocates memory for various different classes with in the <a class="el" href="class_o_p_t3101_1_1device.html" title="This is the master class that integrates all the OPT3101SDK functions. ">OPT3101::device</a> class</li>
</ul>
<h3><a class="el" href="environment_control_8h.html">environmentControl.h</a> <a class="el" href="environment_control_8cpp.html">environmentControl.cpp</a></h3>
<ul>
<li>Environment control template class which <b>users need to implement/modify</b></li>
<li>For eg: To set target to infinity or cover photo diode.</li>
<li>If automated environmental control is not available, users could implement methods with host pause or wait statements and realize the desired functionality (as described in the method name and description) manually.</li>
<li>Appropriate methods from this file/class are called by the SDK at various stages of calibration</li>
</ul>
<h3><a class="el" href="host_controller_8h.html">hostController.h</a> <a class="el" href="host_controller_8cpp.html">hostController.cpp</a></h3>
<ul>
<li>Host control template class which has I2C Read, I2C write, device reset and host sleep commands which <b>users may need to implement/modify</b></li>
<li><a href="http://www.ti.com/tool/OPT3101EVM">OPT3101EVM</a> command controls examples are populated already</li>
<li>Declares global variable "host" which is used by various methods to reset the device and register class to read and write I2C commands to</li>
</ul>
<h3><a class="el" href="_o_p_t3101_register_definition_8h.html">OPT3101Registerdefinition.h</a> <a class="el" href="_o_p_t3101device___register_map_8cpp.html">OPT3101device_RegisterMap.cpp</a></h3>
<ul>
<li>Declares all the registers of <a href="http://www.ti.com/tool/OPT3101EVM">OPT3101EVM</a> device</li>
<li><b>users may comment out the registers not by the system to save compiled code memory</b></li>
</ul>
<h3>Several Calibration Header and C++ Files</h3>
<p><a class="el" href="_o_p_t3101_calibration_8h.html">OPT3101Calibration.h</a> <a class="el" href="_o_p_t3101___calibration_8cpp.html">OPT3101_Calibration.cpp</a> <a class="el" href="_o_p_t3101_crosstalk_8h.html">OPT3101Crosstalk.h</a> <a class="el" href="_o_p_t3101_crosstalk_8cpp.html">OPT3101Crosstalk.cpp</a> <a class="el" href="_o_p_t3101_design_coefficients_8h.html">OPT3101DesignCoefficients.h</a> <a class="el" href="_o_p_t3101_design_coefficients_8cpp.html">OPT3101DesignCoefficients.cpp</a> <a class="el" href="_o_p_t3101frame_data_8h.html">OPT3101frameData.h</a> <a class="el" href="_o_p_t3101_phase_offset_8h.html">OPT3101PhaseOffset.h</a> <a class="el" href="_o_p_t3101_phase_offset_8cpp.html">OPT3101PhaseOffset.cpp</a></p><ul>
<li>Several calibration class declarations have methods to loadFromFile , saveToFile and report the class contents</li>
<li><b>users may need to modify</b> the implementations based on host requirements.</li>
<li>SDK example implementations use c++ std::fstream std::iostream and stdio::printf methods</li>
</ul>
<hr/>
<h2><a class="anchor" id="FAQ"></a>FAQ (Frequency asked Questions)</h2>
<ol type="1">
<li>Why do I need this SDK?<ul>
<li>Actually you don't need this SDK to use <a href="http://www.ti.com/tool/OPT3101EVM">OPT3101EVM</a> or any system build using <a href="http://www.ti.com/product/OPT3101">OPT3101</a> AFE decide.</li>
<li>However using this SDK makes development and debug more efficient and faster.</li>
<li>The application code in the host processor would look like bunch of raw register reads and writes without the SDK.</li>
<li>When using this SDK the application code is more readable and is at a higher level of abstraction.</li>
</ul>
</li>
<li>Okay I see... but still Why?<ul>
<li><a href="http://www.ti.com/lit/ug/sbau310/sbau310.pdf">Calibration</a> of <a href="http://www.ti.com/product/OPT3101">OPT3101</a> typically involve the following...<ul>
<li>Setting up environmental conditions like temperature, covering photo diode or setting up target</li>
<li>Configuring the <a href="http://www.ti.com/product/OPT3101">OPT3101</a> device to a particular mode of operation with a bunch of register settings</li>
<li>Waiting for the <a href="http://www.ti.com/product/OPT3101">OPT3101</a> device to acquired data</li>
<li>Reading back acquired data from the <a href="http://www.ti.com/product/OPT3101">OPT3101</a> device to the host.</li>
<li>Finding out floating point precision coefficients from the acquired data, for some coefficients using curve fitting or regression.</li>
<li>Finding out register scales to translate the floating point precision coefficients to register values and their corresponding scaling values</li>
<li>Writing these coefficients back to the device in production calibration environment</li>
<li>Writing all calibration related registers to a non-volatile memory</li>
</ul>
</li>
<li>Now imagine doing all the above steps using just raw hex reads and writes. Some of the registers are split and they span across multiple addresses.</li>
<li>The application code for this would look cumbersome and non readable making the development and debug inefficient.</li>
<li>Especially true during early stages of development where registers may need to be tweaked to achieve best performance from the system.</li>
<li>SDK provides a simpler abstraction to the register interface and also provides all the calibration functions as methods.</li>
<li>Methods involve setting up the environment, setting up <a href="http://www.ti.com/product/OPT3101">OPT3101</a> device , taking measurements, finding scaling coefficients and register values.</li>
<li>Methods are extended to very high level abstractions like listed in the <a href="#Levels">levels</a> section giving users a simpler approach to the listed complex list of steps</li>
</ul>
</li>
<li>This SDK is in C++, can i get one in C?<ul>
<li>No. The SDK is designed in C++ and will continue to be supported in C++.</li>
</ul>
</li>
<li>Why is this C++ and not C?<ul>
<li>There are several structured data types for different calibrations which needs to interact between one another. Also the register interface needs a cleaner operated overloaded structured entity to make the register reads and writes more meaningful and readable. C++ given a simpler level of abstraction for implementation of these features which C lacks.</li>
</ul>
</li>
<li>I would really like to get C library since I am more familiar with C.<ul>
<li>The library uses very simple C++ constructs, hence using this library doesn't require advanced C++ knowledge. The classes in this library are used as glorified struc entities with self contained methods or functions.</li>
</ul>
</li>
<li>I would really like to get C library since my host processor may not support C++.<ul>
<li>Most application processors developments kits support C and C++ including TI's embedded processors. Even TI's MSP430 series support C++. <br />
7. I would really like to get C library since my existing application code is in C.</li>
<li>C code is fully backward compatible in C++ compiler environment. There are some minor changes to be done to the code to notify the linker that the library included are C based and not C++ based.</li>
<li>Typical syntax for that involves enumerating the includes and the syntax with in extern "C" { } entities.</li>
<li>Users could switch to C++ compiler on the host with minor changes to their existing code, in which case this SDK becomes compatible in their environment.</li>
</ul>
</li>
<li>I like the register access with names, can i get only that portion ?<ul>
<li>Only the files <a href="class_o_p_t3101_1_1registers.html">register.h/register.cpp</a> <a href="class_o_p_t3101_1_1registers.html">OPT3101Registerdefinition.h/OPT3101device_RegisterMap.cpp</a> are good enough to translate the register names to physical address, data. Users can them implement own I2C read write functions based on resolved physical quantities.</li>
</ul>
</li>
<li>Does this come with GUI interface?<ul>
<li>No. This is not a ready to use tool, this is a development kit. Please read <a href="#Limitations">this</a> section</li>
</ul>
</li>
<li>Why are there so many files and classes?<ul>
<li>There are several functions the SDK fulfills mainly the calibration aspects. Each calibration is unique data type with its own set of registers and coefficients. Having a single class for all the calibration types is not possible hence several classes have been declared specifically for each type of calibration containers. These have been split to different files for easy management and readability</li>
</ul>
</li>
<li>What do i need to know before I start using this?<ul>
<li>Please refer to <a href="#Prereq">this</a> section</li>
</ul>
</li>
<li>What are these hostControler and environmentController classes? Why do i need them?<ul>
<li>This is an SDK expected to be used on various different h/w and host configurations.</li>
<li>Given that for eg: the I2C read or write command is very different for each host or h/w.</li>
<li>Similarly to get ambient coefficient, the SDK has to convey to the user the ambient level needs to be set to a particular value.</li>
<li>Conventionally these are provided with pseudo code in the source files which the user needs to implement.</li>
<li>In case of this SDK, instead of pseudo code a template classes have been created with methods which are expected to do these specific tasks.</li>
<li>These methods (whose name and documentation covers the purpose of this method) are called by the SDK at appropriate times.</li>
<li>If users implement the action for these methods according to their host or environmental conditions then the SDK would work seamlessly in their system</li>
<li>For eg: The SDK Calls the method environmentController::setChamberTemperature method when it requires to change the temperature of the environment.</li>
</ul>
</li>
<li>Where do i see detailed documentation for each class or method?<ul>
<li>In the top menu go to Classes&ndash;&gt;Class Hierarchy which is a good starting point. Every file is documented and almost every step in each method/function is documented.</li>
</ul>
</li>
<li>I have more questions and clarifications. How do i each out?<ul>
<li>Please submit a <a href="http://e2e.ti.com">E2E</a> question regarding the same. </li>
</ul>
</li>
</ol>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
